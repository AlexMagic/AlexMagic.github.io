<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Alex's Blogs">
<meta property="og:url" content="http://AlexMagic.github.io/index.html">
<meta property="og:site_name" content="Alex's Blogs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex's Blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"remove","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6396137648292890000',
      author: 'Alex'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexMagic.github.io/"/>





  <title> Alex's Blogs </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://AlexMagic.github.io/2017/03/13/插件化入门：动态代理，反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/插件化入门：动态代理，反射/" itemprop="url">
                  插件化入门：动态代理，反射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T10:23:15+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/插件化/" itemprop="url" rel="index">
                    <span itemprop="name">插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/13/插件化入门：动态代理，反射/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/插件化入门：动态代理，反射/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇会讲述两个基本的概念，一个是动态代理，一个是反射，这两个是你可以认为是实现插件化的最基本的工具，如果你已经有过了解甚至是已经有一定的理解，那你可以跳过这一篇。</p>
<p>目前比较流行的插件化的做法之一就是通过动态代理和反射，进而hook系统中的各种Api服务达到为我所用的地步，插件化的一个重要的思路就是能够欺骗系统来完成动态加载的过程。</p>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>先从Wiki上复制一段定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">所谓代理者是指一个类可以作为其他东西的接口。代理者可以作任何东西的接口, 例如网络连接， 存储器中的大对象，文件或者其他无法复制的资源。</div><div class="line"></div><div class="line">著名的代理模式的例子就是引用计数(reference counting): 当需要一个复杂对象的多份副本时， 代理模式可以结合享元模式以减少存储器的用量。典型做法是创建一个复杂对象以及多个代理者， 每个代理者会引用到原本的对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时， 复杂对象会被移除。</div></pre></td></tr></table></figure>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理， 就是在编译阶段就生成代理类来完成对代理对象的一系列操作。下面是代理模式的结构类图：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/439px-Proxy_pattern_diagram.svg.png" alt=""></p>
<p>从图中可以发现，关于代理模式的有四个基本的角色：</p>
<ul>
<li>主题接口：定义了代理角色和真实角色具有的共同的行为；</li>
<li>真实主题角色：实现了主题接口的具体行为；</li>
<li>代理主题角色：同样实现了主题接口，但是实现的实际上真实主题的行为，在实现代理的过程中可以在真实行为前后定义自己的方法；</li>
<li>客户端角色</li>
</ul>
<p>对应上面的角色以下用java的代码做一个简单的演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> test = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"The real subject request."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> test = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"The real subject request."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> RealSubject realSubject = <span class="keyword">new</span> RealSubject(); </div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		beforeRequest();</div><div class="line">		</div><div class="line">		realSubject.request();</div><div class="line">		</div><div class="line">		afterRequest();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeRequest</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"before request!!!"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterRequest</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"after request!!!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ProxySubject proxy = <span class="keyword">new</span> ProxySubject();</div><div class="line">		proxy.request();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>实际上在java中为我们提供了可以实现动态代理的接口和类，动态代理利用Java的反射技术，在运行时创建一个实现某些给定接口的动态代理类及其实例。在动态代理中有两个重要的接口和类：</p>
<ul>
<li><strong>InvocationHandler</strong>：<br>这个接口是动态代理类需要实现的一个接口，接口中定义了一个方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxy:指代理类；</div><div class="line">method:被代理的方法；</div><div class="line">args:指方法中的参数集合；</div></pre></td></tr></table></figure>
<p>它的作用类似于创建上面静态代理中ProxySubject。</p>
<ul>
<li><strong>Proxy</strong>：<br>这个类是jdk提供给我们可以动态的创建代理对象的，类中提供了一个可以创建出代理对象的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler)</span> <span class="keyword">throws</span> IllegalArgumentException</span></div></pre></td></tr></table></figure>
<p>基于静态代理的例子，我们把ProxySubject改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Subject subject;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		<span class="keyword">this</span>.subject = subject;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"before request!!!"</span>);</div><div class="line">		</div><div class="line">		Object result = method.invoke(subject, args);</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"after request!!!"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//		ProxySubject proxy = new ProxySubject();</span></div><div class="line"><span class="comment">//		proxy.request();</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Subject subject = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()</div><div class="line">				, RealSubject.class.getInterfaces()</div><div class="line">				, <span class="keyword">new</span> ProxyHandler(<span class="keyword">new</span> RealSubject()));</div><div class="line">			subject.request();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后就能看出和静态代理执行的效果是一样的。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。</p>
<p>java在java.lang.reflect包中提供了所有反射用到的类，下列介绍几个核心类：</p>
<ul>
<li>Class：代表一个类</li>
<li>Field：代表了类中的成员变量</li>
<li>Mehod：代表一个类中的方法</li>
<li>Constructor：代表类的构造方法</li>
</ul>
<h3 id="核心Api"><a href="#核心Api" class="headerlink" title="核心Api"></a>核心Api</h3><ul>
<li>获取构造方法（Constructor）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Constructor getConstructor(Class[] params): 根据构造函数的参数，返回一个具体的具有public属性的构造函数;</div><div class="line">Constructor getConstructors(): 返回所有具有public属性的构造函数数组;</div><div class="line">Constructor getDeclaredConstructor(Class[] params): 根据构造函数的参数，返回一个具体的构造函数（不分public和非public属性）;</div><div class="line">Constructor getDeclaredConstructors(): 返回该类中所有的构造函数数组（不分public和非public属性）;</div></pre></td></tr></table></figure>
<ul>
<li>获取类的成员方法（Mehod）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Method getMethod(String name, Class[] parameterTypes): 根据方法名和参数，返回一个具体的具有public属性的方法;</div><div class="line">Method[] getMethods(): 返回所有具有public属性的方法数组;</div><div class="line">Method getDeclaredMethod(String name, Class[] params): 根据方法名和参数，返回一个具体的方法（不分public和非public属性）;</div><div class="line">Method[] getDeclaredMethods(): 返回该类中的所有的方法数组(不分public和非public属性),不包含继承来的方法;</div></pre></td></tr></table></figure>
<ul>
<li>获取类的成员变量（Field）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Field getField(String name) 根据变量名，返回一个具体的具有public属性的成员变量;</div><div class="line">Field[] getFields() 返回具有public属性的成员变量的数组;</div><div class="line">Field getDeclaredField(String name) 根据变量名，返回一个成员变量（不分public和非public属性);</div><div class="line">Field[] getDelcaredField() 返回所有成员变量组成的数组（不分public和非public属性）;</div></pre></td></tr></table></figure>
<h1 id="动态代理和反射在插件化中的应用"><a href="#动态代理和反射在插件化中的应用" class="headerlink" title="动态代理和反射在插件化中的应用"></a>动态代理和反射在插件化中的应用</h1><p>对于想要hook一些系统api的时候 并不是所有的接口都是开放的，但是又需要去做一些修改，这是就需要通过反射来获取这些需要修改的对象，在DroidPlugin中的reflect包里封装了关于反射的一些功能，例如在这个框架的初始化过程中有一个安装个中国系统服务的过程(其实就是hook掉系统的服务)，其中都要执行一个onInstall方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInstall</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">new</span> ServiceManagerCacheBinderHook(mHostContext, getServiceName()).onInstall(classLoader);</div><div class="line">    mOldObj = getOldObj();</div><div class="line">    Class&lt;?&gt; clazz = mOldObj.getClass();</div><div class="line">    List&lt;Class&lt;?&gt;&gt; interfaces = Utils.getAllInterfaces(clazz);</div><div class="line">    Class[] ifs = interfaces != <span class="keyword">null</span> &amp;&amp; interfaces.size() &gt; <span class="number">0</span> ? interfaces.toArray(<span class="keyword">new</span> Class[interfaces.size()]) : <span class="keyword">new</span> Class[<span class="number">0</span>];</div><div class="line">    Object proxiedObj = MyProxy.newProxyInstance(clazz.getClassLoader(), ifs, <span class="keyword">this</span>);</div><div class="line">    MyServiceManager.addProxiedObj(getServiceName(), proxiedObj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就利用了动态代理和反射实现了对系统服务的替换，至于具体是怎么替换以及为什么选择这里替换将会在后面分析DroidPlugin的源码中讲述。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本篇主要就是介绍了一些动态代理和反射的概念，主要是对后面的内容起个铺垫作用，如果想更加深入的了解这里推荐大家看一下IBM developerWorks里面关于反射的<a href="https://www.ibm.com/developerworks/cn/java/j-dyn0429/" target="_blank" rel="external">介绍</a>。</p>
<p>感谢看到最后，欢迎各位提出宝贵的意见和纠正错误，共同学习。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://AlexMagic.github.io/2017/03/12/Android插件化基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/12/Android插件化基础/" itemprop="url">
                  Android插件化基础概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T21:32:38+08:00">
                2017-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/插件化/" itemprop="url" rel="index">
                    <span itemprop="name">插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/12/Android插件化基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/12/Android插件化基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>在过去的一个月里我把大部分精力都放在了学习插件化的内容，虽然google并不提倡这门技术，而且就在这两天苹果已经声明了禁止把实现了插件化功能的应用放到appStore上。但是经过我的学习之后发现，即便是将来google也明令禁止，这门技术也十分值得各位深入的学习一下，就Android而言，通过插件化的学习，你能对Android Framework层有更深的认识，对Android的系统机制能有更加清楚的概念。虽然鄙人的水平也不是很出众，但是还是坚持的学习了一番，获益良多，因此决定把这段时间学习的心得分享给各位，互相学习。</p>
<p>从这篇开始，我会将插件化用到的原理都介绍一番，这里十分推荐这位大神的<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/" target="_blank" rel="external">分享</a>，他把很多的原理解释的比较的清楚，我也是看了他的系列文章才开始学习插件化的。之后我会通过分析目前公认的比较好的插件化框架之一的<a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>来阐述该框架的实现原理。</p>
<h1 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h1><p>插件化这个概念大概是在2015年前后开始热门起来，这项技术能够火起来有很多原因：</p>
<ol>
<li>随着应用体积的增大，很多的应用比如微信，淘宝这样的巨型应用里的方法数都超过了65535的上限，同时，随着各种办法的发布，传统的升级也会给用户带来不小的困扰从而提出热更新的概念。</li>
<li>这些大型应用往往不是有是由不同的部门协同完成，每个团队维护着同一个应用是一件非常伤脑经的事，对应用的升级和维护将会是一个很大的困扰。</li>
</ol>
<p>纵使有H5来代替一些页面，但是和原生的应用应用相比在体验上还是会有很大的差异，如何既能像Web应用那样不需要关心用户升级问题，又能做到原生的体验是很多的开发者都在思考的。与此同时，facebook推出了同样是目前很火的框架React-Native，可以说是很好的将web和native结合起来的技术，可以说它和插件化一样解决了企业和用户之间的痛点，虽然两者的实现截然不同，前者是利用JS调用原生控件，而后者则是纯native开发。</p>
<p>既然是插件化，实际上就是要做到动态加载插件apk，当中涉及到要做的工作有这么几点：</p>
<ul>
<li>动态加载代码</li>
<li>动态访问资源</li>
<li>ClassLoader的管理</li>
</ul>
<p>目前国内开源的较成熟的插件方案有DL和DroidPlugin；但是DL方案仅仅对Frameworl的表层做了处理，严重依赖that语法，编写插件代码和主程序代码需单独区分；而DroidPlugin通过Hook增强了Framework层的很多系统服务，开发插件就跟开发独立app差不多；就拿Activity生命周期的管理来说，DL的代理方式就像是牵线木偶，插件只不过是操纵傀儡而已；而DroidPlugin则是借尸还魂，插件是有血有肉的系统管理的真正组件；DroidPlugin Hook了系统几乎所有的Sevice，欺骗了大部分的系统API；掌握这个Hook过程需要掌握很多系统原理，因此学习DroidPlugin对于整个Android FrameWork层大有裨益。</p>
<p>接下来的文章中会从最基本的技术开始，包括动态代理，反射以及我们是如何hook掉系统服务的，毕竟我也是比较艰难的一步一步的学下去的，希望能给那些想入门的童鞋们一些帮助吧，我把关于这部分的内容都写在了<a href="https://alexmagic.github.io/categories/插件化/">插件化</a>这个分类当中，感兴趣的可以在关注一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://AlexMagic.github.io/2017/01/12/Android-异步消息处理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/12/Android-异步消息处理机制/" itemprop="url">
                  Android 异步消息处理机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-12T18:46:29+08:00">
                2017-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/12/Android-异步消息处理机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/12/Android-异步消息处理机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇我们来聊聊关于Android异步消息的相关内容，其实关于Android的异步消息的处理对于每一位Android的开发者而言都是必须要烂熟于心的，因为在日常的学习和开发中都需要用到。由于Android的主线程即UI线程是不安全的，如果在子线程中就更新UI会导致程序直接崩溃，那么常规的做法就是在主线程中创建一个Handler对象并实现handleMessage方法，然后在子线程中获取Message对象，通过Handler发送出去并在handleMessage中接受这个Message对象，这样就能根据这个对象的内容在主线程中进行绘制的工作了。</p>
<p>相信大家在对使用Handler上应该是十分熟悉的了，那么问题就来了，就是Android是如何利用Handler将子线程中的内容发送到主线程中的呢？这个就是本篇要讨论的问题，实际上Android是通过Looper , Handler , Message这三者的合作来完成异步消息的处理，接下来我们来看看它们到底是怎么样进行工作的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="1-Looper"><a href="#1-Looper" class="headerlink" title="1.Looper"></a>1.Looper</h2><p>首先看看Looper这个类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造方法中， Looer会创建一个MessageQueue对象和以及获取当前的线程对象。</p>
<p>在这个类中有两个方法：</p>
<p>prepare()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">  * This gives you a chance to create handlers that then reference</div><div class="line">  * this looper, before actually starting the loop. Be sure to call</div><div class="line">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>sThreadLocal是一个ThreadLocal对象，可以在一个线程中存储变量。</p>
<p>可以看到，在第5行，将一个Looper的实例放入了ThreadLocal，并且2-4行判断了sThreadLocal是否为null，否则抛出异常。这也就说明了Looper.prepare()方法不能被调用两次，同时也保证了一个线程中只有一个Looper实例。</p>
<p>loop():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法可以看出方法一开始就会获取当前线程的Looper对象和MessageQueue对象：<br>final Looper me = myLooper();<br>final MessageQueue queue = me.mQueue;<br>接下来就是通过死循环一直取MessageQueue里的Message对象，如果取到的对象不为空则会执行msg.target的dispatchMessage方法，msg.target实际上是一个Handler对象.</p>
<p>Looper主要作用：</p>
<ol>
<li>与当前线程绑定，保证一个线程只会有一个Looper实例，同时一个Looper实例也只有一个MessageQueue。</li>
<li>loop()方法，不断从MessageQueue中去取消息，交给消息的target属性的dispatchMessage去处理。</li>
</ol>
<p>好了，我们的异步消息处理线程已经有了消息队列（MessageQueue），也有了在无限循环体中取出消息的哥们，现在缺的就是发送消息的对象Handler。</p>
<h2 id="2-Handler"><a href="#2-Handler" class="headerlink" title="2.Handler"></a>2.Handler</h2><p>使用Handler之前，我们都是初始化一个实例，比如用于更新UI线程，我们会在声明的时候直接初始化，或者在onCreate中初始化Handler实例。所以我们首先看Handler的构造方法，看其如何与MessageQueue联系上的，它在子线程中发送的消息（一般发送消息都在非UI线程）怎么发送到MessageQueue中的。</p>
<p>Handler的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造方法里 首先要判断当前线程的Looper对象是否为空 ， 如果不为空则获取这个Looper对象的MessageQueue对象。</p>
<p>通过在子线程获取了Message对象并把一些数据赋值给这个对象之后就会执行sendMessage这个方法，或者是sendEmptyMessage方法，接下来我们就以sendEmptyMessage为例看看它的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> * Sends a Message containing only the what value.</div><div class="line"> *  </div><div class="line"> * <span class="meta">@return</span> Returns <span class="keyword">true</span> <span class="keyword">if</span> the message was successfully placed in to the </div><div class="line"> *         message queue.  Returns <span class="keyword">false</span> on failure, usually because the</div><div class="line"> *         looper processing the message queue is exiting.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">    Message msg = Message.obtain();</div><div class="line">    msg.what = what;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>辗转反则最后调用了sendMessageAtTime，在此方法内部有直接获取MessageQueue然后调用了enqueueMessage方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enqueueMessage中首先为meg.target赋值为this，【如果大家还记得Looper的loop方法会取出每个msg然后交给msg.target.dispatchMessage(msg)去处理消息】，也就是把当前的handler作为msg的target属性。最终会调用queue的enqueueMessage的方法，也就是说handler发出的消息，最终会保存到消息队列中去。</p>
<p>现在已经很清楚了Looper会调用prepare()和loop()方法，在当前执行的线程中保存一个Looper实例，这个实例会保存一个MessageQueue对象，然后当前线程进入一个无限循环中去，不断从MessageQueue中读取Handler发来的消息。</p>
<p>dispathMessage()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法中最终会调用在创建Handler对象时需要重写的一个handleMessage()方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述的内容讲述一个关于异步消息处理的核心流程，因此我们来总结一下这一过程的基本流程：</p>
<ol>
<li>首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。</li>
<li>Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。</li>
<li>Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。</li>
<li>Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</li>
<li>在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。</li>
</ol>
<p>在实际开发中，我们并没有显示的调用Looper.prepare()和Looper.loop()方法，为啥Handler可以成功创建呢，这是因为在Activity的启动代码中，已经在当前UI线程调用了Looper.prepare()和Looper.loop()方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://AlexMagic.github.io/2016/11/10/基于MVP模式搭建Android应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/10/基于MVP模式搭建Android应用/" itemprop="url">
                  基于MVP模式搭建的Android应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-10T23:09:03+08:00">
                2016-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/10/基于MVP模式搭建Android应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/10/基于MVP模式搭建Android应用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客是我个人的处女作，想了很久要以什么作为我博客的第一篇文章，最后选择了写下这篇关于MVP的架构的内容，当中也是有些原因的：<br>我是今年毕业的，到目前为止算算日子在现在这家公司也已经工作了一段时间了，作为一个新人我到公司之后首先就是要从零开始做一些他们终端里面的应用。在我还是学生接触Android的一段时间里都是传统的MVC的方式搭建一个应用，经过一番了解到了MVC并不是很适合移动端的开发，而目前比较主流的方式是MVP和MVVM，因此也是从这个时候开始学习MVP这种架构的思路，所以决定写下这篇入门MVP的文章，初次写稿肯定会有很多不好的地方，希望你们即便不喜欢也能假装喜欢的样子，各位看客轻拍哦。</p>
<h2 id="谈谈MVP"><a href="#谈谈MVP" class="headerlink" title="谈谈MVP"></a>谈谈MVP</h2><p>在网络上关于什么MVP、MVVM之类的已经很多很好的文章说明了这些模式之间的区别与优劣势，在这里我也就不班门弄斧了，主要谈谈我对MVP的一些认识。</p>
<p>说到MVP就不得不说一下传统的MVC模式，首先先放上一张在google里搜的关于两种模式的图：</p>
<p><img src="http://frodoking.github.io/img/android/mvp_mvc_img.png" alt=""></p>
<p>回想一下过去不管是实际的项目还是自己学习练手的工程，不知道有没有一种感觉就是虽然使用了MVC的思路在写代码，但是会发现在Activity中会有大量的业务逻辑冗余在其中，这是因为Activity在MVC中扮演的Controller的角色，而Android架构本身的原因，需要在主线程根据接口返回的数据绘制的View上，导致View与Model产生了过多的联系很多操作都耦合在了Activity中，不论是看起来还是写起来既不好看也不好维护，比较理想的情况是View层里面应用只关心UI之间的交互，而不应该直接的Model产生联系。而MVP的核心思想就是不让View和Model直接关联，而是通过Presenter贯穿两者之间。</p>
<p>可以看出MVP的优点：</p>
<ul>
<li>思路会比较的清晰，因为每个部分都彼此分离，模块之间的耦合度减小；</li>
<li>View和Model分离，通过Presenter相互关联，在Presenter中负责大部分的业务逻辑；</li>
<li>在Presenter中可以更好的对Model进行相关的操作；</li>
<li>更好的实现模块化，方便写测试用例；</li>
</ul>
<p>当然也有它的劣势的地方：</p>
<ul>
<li>容易导致在Presenter中做过多的工作，看起来比较冗余；</li>
<li>过多的接口会显得代码量增大；</li>
</ul>
<h2 id="EasyMvpBuilder"><a href="#EasyMvpBuilder" class="headerlink" title="EasyMvpBuilder"></a>EasyMvpBuilder</h2><p>在接下来的工程里我会调用豆瓣一个的Api来说明这个过程，各位同学们可以先把<a href="https://github.com/AlexMagic/EasyMvpBuilder" target="_blank" rel="external">EasyMvpBuilder</a>这个工程clone下来看看。</p>
<h3 id="easy-mvp"><a href="#easy-mvp" class="headerlink" title="easy_mvp"></a>easy_mvp</h3><p>首先看一下easy_mvp这个module的包结构：<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp.png?raw=true" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- base : View和Presenter的基本接口</div><div class="line">- interactor : 交互器集合，用来处理网络交互的过程</div><div class="line">- model : 基本模型</div><div class="line">- net : </div><div class="line">  - api:处理网络请求</div><div class="line">  - okHttp:对okHttp请求和响应数据的封装</div><div class="line">- utils :工具包</div></pre></td></tr></table></figure>
<p>以下是该框架用到的第三方的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.google.code.gson:gson:2.3.1&apos;</div><div class="line">compile &apos;com.squareup.okhttp:okhttp:2.5.0&apos;</div><div class="line">compile &apos;io.reactivex:rxjava:1.0.14&apos;</div><div class="line">compile &apos;io.reactivex:rxandroid:1.0.1&apos;</div></pre></td></tr></table></figure>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>base下是两个接口，这两个接口分别是Presenter和View基类，都定义了一些方法。</p>
<p><strong>net:</strong></p>
<p>在api包下ApiConnection封装了okHttp的请求过程，<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp_apiconnect.png?raw=true" alt=""><br>Api是个抽象类，里面的主要的工作就是实现对网络接口的请求，定义了一个抽象方法getResponseData()，而ApiDefaultResponseImpl则是这个抽象类的实现类。<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp_api.png?raw=true" alt=""><br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp_default_api.png?raw=true" alt=""></p>
<p><strong>interactor:</strong></p>
<p>这个部分的工作就是用来启动一次访问数据的操作的，定义一个抽象类UseCase。<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp_usecase.png?raw=true" alt=""><br>里面抽象了一个方法buildUseCaseObservable(Class clz)，DefaultUseCase有具体实现的方法。<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_mvp_default_usecase.png?raw=true" alt=""></p>
<p>至此就是这个module所做的所有工作，利用了Rxjava，在数据类型的转化上面看起来就非常的简单，下面一个部分就会讲述一下一次简单的接口访问的过程。</p>
<h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/easy_app.png?raw=true" alt=""></p>
<p>本次例子调用的豆瓣v2的搜索图书的接口，为了简单和方便，我把要搜索的内容写死为“python入门”，估计是因为本人近期在学习机器学习方面的知识，所有脑袋第一时间想的就是python……到这里就要开始对mvp的具体实现了，首先看到我们熟悉的Activity：<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/app_activity.png?raw=true" alt=""><br>它实现了一个BooksView的接口，实际上这个接口继承自BaseView，在onCreate()里面对SearchBooksPresenter进行实例化，并把当前的view引用传进去，接下来就来到了比较重要的Presenter了，在这里你们能看到它是如何将View和Model关联起来的：<br><img src="https://github.com/AlexMagic/SimpleResources/blob/master/EasyMvpBuilder/app_presenter.png?raw=true" alt=""><br>这个类实现了BasePresenter的接口，并且包含了BooksView的引用，在getDoubanBooks()这个方法里面，通过上述提到的DefaultUseCase发起请求，并在DoubanBookSubscriber中实现对Model的回调同时对View进行相关的操作，这里就是把书单都展示出来。</p>
<p>到这里整个主要的过程都已经讲述完毕，从结构上看起来还是比较清晰的，在Activity中你只需要关心View的逻辑，而在数据上也只要去实现如果获取，剩下的就由Presenter来做了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>经过一段时间的学习，我个人还是比较喜欢MVP的模式，虽然会有一些缺点，但总体而言还是不错的思想，这次写的例子还有很多可以丰富的地方，日后会慢慢加上，如果大家觉得写的还行欢迎star一下，觉得哪里写的不太好也希望大家能够指出，共同学习。</p>
<p>最后还是要感谢一位大神的文章<a href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">architecting-android-the-clean-way</a>，我也是从这篇文章开始学习MVP这种架构的，同时里面也用到了很多目前很流行的库比如Rxjava，dagger2等。</p>
<p>感谢各位看到最后。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"alexgo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
